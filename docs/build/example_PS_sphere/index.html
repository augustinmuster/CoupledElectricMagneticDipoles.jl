<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PS Sphere · CoupledElectricMagneticDipoles.jl</title><meta name="title" content="PS Sphere · CoupledElectricMagneticDipoles.jl"/><meta property="og:title" content="PS Sphere · CoupledElectricMagneticDipoles.jl"/><meta property="twitter:title" content="PS Sphere · CoupledElectricMagneticDipoles.jl"/><meta name="description" content="Documentation for CoupledElectricMagneticDipoles.jl."/><meta property="og:description" content="Documentation for CoupledElectricMagneticDipoles.jl."/><meta property="twitter:description" content="Documentation for CoupledElectricMagneticDipoles.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="CoupledElectricMagneticDipoles.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="CoupledElectricMagneticDipoles.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CoupledElectricMagneticDipoles.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../ddacore/">DDACore</a></li><li><a class="tocitem" href="../alphas/">Alphas</a></li><li><a class="tocitem" href="../input_fields/">InputFields</a></li><li><a class="tocitem" href="../postprocessing/">PostProcessing</a></li><li><a class="tocitem" href="../forces/">Forces</a></li><li><a class="tocitem" href="../green/">GreenTensors</a></li><li><a class="tocitem" href="../miecoeff/">MieCoeff</a></li><li><a class="tocitem" href="../geometries/">Geometries</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>PS Sphere</a><ul class="internal"><li><a class="tocitem" href="#Discretizing-the-Sphere"><span>Discretizing the Sphere</span></a></li><li><a class="tocitem" href="#Computing-the-Polarizabilities"><span>Computing the Polarizabilities</span></a></li><li><a class="tocitem" href="#Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections"><span>Solving the DDA Problem and Computing the Total Scattering Cross Sections</span></a></li><li><a class="tocitem" href="#Computing-the-Differential-Scattering-Cross-Sections"><span>Computing the Differential Scattering Cross Sections</span></a></li><li><a class="tocitem" href="#A-Note-on-Convergence"><span>A Note on Convergence</span></a></li></ul></li><li><a class="tocitem" href="../example_yagi_uda/">Yagi-Uda Antenna</a></li><li><a class="tocitem" href="../example_ldos_silver_np/">LDOS Silver Particle</a></li><li><a class="tocitem" href="../example_force_gaussbeam_PS_sphere/">Optical Trap</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>PS Sphere</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PS Sphere</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/augustinmuster/DDAjulia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/augustinmuster/DDAjulia/blob/master/docs/src/example_PS_sphere.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere"><a class="docs-heading-anchor" href="#Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere">Total and Differential Scattering Cross Sections of a Polystyrene Sphere</a><a id="Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere-1"></a><a class="docs-heading-anchor-permalink" href="#Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere" title="Permalink"></a></h1><p>This example aims to teach the user how to use CEMD.jl in only electric mode. For this we will compute the total and differential scattering cross section of a polystyrene (PS) sphere with a radius of 500nm in water. We will then compare it with Mie theory.</p><p><strong>Be careful:</strong> using the electric DDA for solving this type of problems is not optimal at all (way to slow and not accurate). The sizes and refractive indices used in this example make the problem converge reasonably well (see last section) and is then a nice figure of merit for this software. If you need to solve the light scattering problem of a sphere, it is better to use directly Mie theory. </p><p>If you don&#39;t now what a DDA problem is, please first have a look to the theory part.</p><p>If you want to run this example, copy it or download it on the github (<code>example_PS_sphere.jl</code>) and run it using </p><pre><code class="language-bash hljs">julia example_PS_sphere.jl
</code></pre><p>If you can, it is recommanded to run it in parallel, using the <code>--threads</code> option. </p><p>Let&#39;s start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results. LinearAlgebra and Lebedev are used to perform integrals on the surface of a sphere (<a href="https://github.com/stefabat/Lebedev.jl">Lebedev.jl</a>).</p><pre><code class="language-julia hljs">#imports
using CoupledElectricMagneticDipoles
using PyCall
using LaTeXStrings
using Lebedev
using LinearAlgebra
@pyimport matplotlib.pyplot as plt
</code></pre><h2 id="Discretizing-the-Sphere"><a class="docs-heading-anchor" href="#Discretizing-the-Sphere">Discretizing the Sphere</a><a id="Discretizing-the-Sphere-1"></a><a class="docs-heading-anchor-permalink" href="#Discretizing-the-Sphere" title="Permalink"></a></h2><p>We then need to start modelizing our particle in water. For, this we start by defining the parameters of the simulation. PS has a refractive index of 1.59 (we consider no absorption, so no imaginary part). For water, it is 1.33. We can then set the dielectric constant of the particle <code>eps</code> and of the medium <code>eps_h</code> using <span>$\epsilon=n^2$</span>. </p><pre><code class="language-julia hljs">##################### Parameters ########################################
#radius (in nm)
a=250
#dielectric constant of the particle
eps=(1.59)^2
#dielectric constant of the medium
eps_h=(1.33)^2
#number of wavelengths to compute (in nm)
N_lambda=10
lambda_min=1000
lambda_max=1100
#wavelengths to compute
lambdas0=LinRange(lambda_min,lambda_max,N_lambda)
lambdas=lambdas0/sqrt(eps_h)
##########################################################################</code></pre><p><code>lambdas0</code> are the wavelength for which we want to compute the scattering cross section (here between 1000 and 1100nm). We directly computes the wavelength in medium by dividing by the refractive index. Note that we always use the wavenumber in the medium in the software.</p><p>We can then discretize the sphere in small cubes using <code>Geometries.discretize_sphere</code>. The first parameter is the radius of the sphere and the second is the number of cubes to place in the diameter of the sphere (it will set the total number of cubes of the discretized sphere).</p><pre><code class="language-julia hljs">#discretizes a sphere in small cubes
latt,dx=Geometries.discretize_sphere(a,10)</code></pre><p>If N is the number of cubes in the discretized sphere, this function returns a Nx4 array <code>latt</code>, that contains the coordinates of the center of each cube, as well as its filling fraction (If the cube is in the bulk, the filling fractions is 1. If it is on the surface, the filling fraction can be smaller than 1, depending on volume fraction of the sphere really inside the sphere.). It also returns <code>dx</code>, which is the length of the edges of all the cubes.</p><p>Here for instance, the number of cubes in the discretized sphere is N=720.</p><h2 id="Computing-the-Polarizabilities"><a class="docs-heading-anchor" href="#Computing-the-Polarizabilities">Computing the Polarizabilities</a><a id="Computing-the-Polarizabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-Polarizabilities" title="Permalink"></a></h2><p>Now that the sphere is discretized, we need to assign to every cube a polarizability. This polarizability is wavelength dependant and then we nee to create an array to store teh results of the cross section cslculations for each wavelength. For this, we use:</p><pre><code class="language-julia hljs">#getting number of cubes in the discretized sphere
n=length(latt[:,1])
#create an array to store results
res=zeros(Float64,N_lambda,3)</code></pre><p>We can then open a loop and computes the polarizability of each cube as follows:</p><pre><code class="language-julia hljs">#solves DDA problem for each wavelength
for i=1:N_lambda
    #wavenumber in medium
    knorm=2*pi/lambdas[i]
    #computes polarizability for each dipoles using effective dielectric constant 
    alpha=zeros(ComplexF64,n,3,3)
    for j=1:n
        eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h
        alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)
    end</code></pre><p>Here, we first compute the wavenumber in the medium and then, using the second loop, assign a polarizability to each cube. <code>Alphas.alpha0_parallelepiped</code> computes the quasistatic polarizability tensor (a 3x3 complex matrix with units of volume) of a cube. Here, we use <code>eps_eff</code>, which is the filling fraction-ponderated mean between the dielectric constant inside and outside the medium. Then, we need to apply the radiative correction to the polarizability using <code>Alphas.alpha_radiative</code>. This last function also renormalize the polarizability from units of volume to no dimensions. We need this because the functions to solve the DDA problem require dimensionless inputs (see the home page and the theory part for more information!).</p><h2 id="Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections"><a class="docs-heading-anchor" href="#Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections">Solving the DDA Problem and Computing the Total Scattering Cross Sections</a><a id="Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections" title="Permalink"></a></h2><p>Before solving the DDA, problem, we need to choose an input field. We will take a x-polarized plane wave propagating along the positive z axis. For this, we use <code>inputFields.plane_wave_e</code>. This functions takes the dimensionless positions <code>kr</code> of the center of the cubes (i.e. the wavenumber times the coordinates array) and outputs a Nx3 array that represent the input field on each of the dipoles.</p><pre><code class="language-julia hljs">    #computes input_field, an x-polarized plane-wave propagating along z
    input_field=InputFields.plane_wave_e(knorm*latt[:,1:3])</code></pre><p>We can now solve the DDA problem between all the dipoles using <code>DDACore.solve_DDA_e</code>:</p><pre><code class="language-julia hljs">    #solves DDA
    e_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=&quot;CPU&quot;)</code></pre><p>The solver is set to <code>&quot;CPU&quot;</code>, that means that the system of linear equations is going to be solved using the CPU and LAPACK, called from julia. This outputs a Nx3 complex array containing the incident field on each dipole. This incident field can the be used to compute the extinction, absorption and scattering total cross sections (<span>$\sigma_{ext},\ \sigma_{abs},\ \sigma_{sca}$</span>) by calling <code>PostProcessing.compute_cross_sections_e</code>.</p><pre><code class="language-julia hljs">    #computes cross section and save it in folder
    res[i,1:end]=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)
end</code></pre><p>This function is just returning <span>$\sigma_{ext},\ \sigma_{abs},\ \sigma_{sca}$</span> in a float array. This results is directly saved in <code>res</code>, that we created before.</p><p>It is now possible to plot the normalized scattering cross section (<span>$Q_{sca}=\sigma_{sca}/\pi a^2$</span>) as a function of the vacuum wavelength divided by the radius <span>$\lambda_0 /a$</span>. To check that the result we obtain is correct, we compare with Mie theory (using the MieCoeff module). We also plot the error <span>$(Q_{ext}-Q_{abs}-Q_{abs})/Q_{ext}$</span> to check tha t the optical theorem, i.e. <span>$\sigma_{ext}=\sigma_{abs}+sigma_{sca}$</span> is well fulfilled. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library, but you can plot it with any software of your choice. </p><pre><code class="language-julia hljs">#scattering cross section from the Mie theory
res_mie=MieCoeff.mie_scattering.(2 .*pi./lambdas*a,eps,eps_h;cutoff=50)

#plotting the cross sections using matplotlib
fig1,ax1=plt.subplots(2,sharex=true)
#sets axis labels
ax1[1].set_ylabel(L&quot;Q_{sca}&quot;)
ax1[2].set_ylabel(L&quot;(Q_{ext}-Q_{abs}-Q_{abs})/Q_{ext}&quot;)
ax1[2].set_xlabel(L&quot;\lambda_0/a&quot;)
#plot
cst=pi*a^2
ax1[1].plot(lambdas0./a,res[:,3]./cst,color=&quot;black&quot;,label=&quot;DDA, N=&quot;*string(n),marker=&quot;o&quot;)
ax1[1].plot(lambdas0./a,res_mie,color=&quot;red&quot;,label=&quot;Mie&quot;,marker=&quot;o&quot;)
ax1[2].plot(lambdas0./a,(res[:,1].-res[:,2].-res[:,3])./res[:,1],color=&quot;black&quot;,marker=&quot;o&quot;)
#legend and save
ax1[1].legend()
plt.tight_layout()
fig1.savefig(&quot;Q_sca.svg&quot;)</code></pre><p>This is what we get:</p><img src="../assets/Q_sca.svg"><p>We see that the DDA cross section is not exactly the same that the Mie one and that the energy is correctly conserved.. For more information, a small convergence study is shown in the last section of this example (without code).</p><h2 id="Computing-the-Differential-Scattering-Cross-Sections"><a class="docs-heading-anchor" href="#Computing-the-Differential-Scattering-Cross-Sections">Computing the Differential Scattering Cross Sections</a><a id="Computing-the-Differential-Scattering-Cross-Sections-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-Differential-Scattering-Cross-Sections" title="Permalink"></a></h2><p>In this part of the example, we want to compute the differential scattering cross section in the y-z plane of the same sphere (we fix here the wavelength to be <code>lambdas[1]</code>, i.e. 1000nm in vacuum). To start, we just solve the DDA problem and computes cross sections as we did previously.</p><pre><code class="language-julia hljs">#computes polarizability for each dipoles using effective dielectric constant 
knorm=2*pi/lambdas[1]
alpha=zeros(ComplexF64,n,3,3)
for j=1:n
    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h
    global  alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)
end

#computes input_field, an x-polarized plane-wave propagating along z
input_field=InputFields.plane_wave_e(knorm*latt[:,1:3])
#solves DDA
e_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=&quot;CPU&quot;)
#computes cross section
cs=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)
</code></pre><p>Then, we define a array of angle <code>thetas</code> in order to generate a uniform sampling <code>ur</code> of the units vectors in the y-z plane.</p><pre><code class="language-julia hljs">#sampling direction an plotting 
thetas=LinRange(0,2*pi,100)
ur=zeros(100,3)
ur[:,3]=cos.(thetas)
ur[:,2]=sin.(thetas)
</code></pre><p>using this array of directions, we can compute the differential cross section in all of these directions using <code>PostProcessing.diff_scattering_cross_section_e</code>. This takes the same positional arguments as <code>PostProcessing.compute_cross_sections_e</code>, but just adding the array of directions. It outputs an array containing the differential scattering cross section in all the directions contained in <code>ur</code>.</p><pre><code class="language-julia hljs">#computes differential cross section
res=PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,ur)</code></pre><p>We can plot it with a radial projection. This time again, we plot the normalized scattering cross section.</p><pre><code class="language-julia hljs">#plotting
fig2=plt.figure()
ax2 = fig2.add_subplot(projection=&quot;polar&quot;)
ax2.set_title(L&quot;log(d Q_{sca}/ d \Omega)&quot;)
ax2.plot(thetas,log10.(res/pi/(a^2)),label=&quot;y-z plane&quot;)
plt.tight_layout()
fig2.savefig(&quot;diff_Q_sca.svg&quot;)</code></pre><img src="../assets/diff_Q_sca.svg"><p>On this plot, the input wave is coming from the left side. We see that most of the light is forward scattered. </p><p>For a sanity check, we can try to integrate the differential scattering cross section on the unit sphere using <a href="https://github.com/stefabat/Lebedev.jl">Lebedev.jl</a> and compare with the total scattering cross section. </p><pre><code class="language-julia hljs">#Compare total scattering cross section and integral of the differential one
x,y,z,w = lebedev_by_order(13)
csca_int=4 * pi * dot(w,PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,[x y z]))
println(cs[3],&quot; : &quot;,csca_int)</code></pre><p>It outputs</p><pre><code class="language-bash hljs">50042.00684959106 : 50042.00684909766
</code></pre><p>showing, that they are the same.</p><h2 id="A-Note-on-Convergence"><a class="docs-heading-anchor" href="#A-Note-on-Convergence">A Note on Convergence</a><a id="A-Note-on-Convergence-1"></a><a class="docs-heading-anchor-permalink" href="#A-Note-on-Convergence" title="Permalink"></a></h2><p>As seen in the previous sections, the scattering cross section obtained with N=720 cubes/dipoles don&#39;t match perfectly with the mie solution (a bit more than 1%). But what happens if we change the number of cubes? We repeated the calculations of the total scattering cross section but with several number of dipoles (from 117 to 9549). Here are the results: </p><img src="../assets/test_conv.svg"><p>What we see is that the error starts to be way smaller for numbers of dipoles bigger than 2295. The example of the PS sphere works quite well, but <strong>be careful</strong>, this doesn&#39;t mean that it will converge like that for every types of spheres. If you want to do that with another sphere made of another material or another object, <strong>check the convergence!</strong>. Recall also that DDA is not the best method to solve light scattering problems by a sphere. <strong>If you don&#39;t really need it, prefer to use Mie Theory</strong>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../geometries/">« Geometries</a><a class="docs-footer-nextpage" href="../example_yagi_uda/">Yagi-Uda Antenna »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 31 January 2024 16:49">Wednesday 31 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
